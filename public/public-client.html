<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>EMDR Client</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #000000; font-family: sans-serif; }
    #ball { width: 50px; height: 50px; border-radius: 50%; position: absolute; background-color: #FFFFFF; }
    #colorChooser { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(255, 255, 255, 0.95); padding: 25px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); text-align: center; z-index: 10; }
    #colorChooser label { font-size: 18px; color: #333; }
    #colorChooser select { margin-top: 10px; padding: 5px; font-size: 14px; min-width: 150px; }
    #colorChooser option { padding: 4px; }
  </style>
</head>
<body>
  <div id="colorChooser">
    <label for="clientBallColor">ボールの色を選んでください</label><br>
    <select id="clientBallColor"></select>
  </div>
  <div id="ball"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const socket = io();

      // --- DOM要素 ---
      const ball = document.getElementById("ball");
      const colorChooser = document.getElementById("colorChooser");
      const clientBallColorSelect = document.getElementById("clientBallColor");

      // --- Audio関連 ---
      const audioPlayer = new Audio(); // BGM用
      let musicPlaylist = [];
      let currentTrackIndex = 0;
      let audioContext, panner; // 衝突音用
      let panDirection = -1, isAudioEnabled = false, isAudioInitialized = false;

      // --- ボール状態 ---
      const ballSize = { width: 50, height: 50 };
      let position = { x: (window.innerWidth - ballSize.width) / 2, y: (window.innerHeight - ballSize.height) / 2 };
      ball.style.left = position.x + "px"; ball.style.top = position.y + "px";
      let direction = { x: 1, y: 0 }, speed = 5, animationId = null, movePattern = 'horizontal';
      let isStopping = false, hasReachedEdge = false, stopProgress = 0;
      const stopDuration = 120;
      let returnStartPosition;
      const angle = 15, angleRad = angle * Math.PI / 180;
      const dirX = Math.cos(angleRad), dirY = Math.sin(angleRad);

      // --- 関数定義 ---
      function initAudio() {
        if (isAudioInitialized) return;
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          panner = audioContext.createStereoPanner();
          panner.connect(audioContext.destination);
          isAudioInitialized = true;
        } catch(e) { console.error("Web Audio API is not supported."); }
      }

      function playCollisionSound() {
        if (!isAudioEnabled || !isAudioInitialized) return;
        if (audioContext.state === 'suspended') audioContext.resume();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.connect(gainNode).connect(panner);
        panner.pan.setValueAtTime(panDirection, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
        oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1);
        panDirection *= -1;
      }
      
      // ▼▼▼ 追加: クライアント側でBGMを再生する関数 ▼▼▼
      function playSongAtIndex(index) {
        if (index < musicPlaylist.length) {
          const trackToPlay = musicPlaylist[index];
          audioPlayer.src = trackToPlay;
          audioPlayer.play().catch(e => console.error(`クライアント再生エラー: ${e}`));
        }
      }

      function updateDirection() { /* (変更なし) */ }
      function stopBall() { /* (変更なし) */ }
      function moveBall() { /* (変更なし) */ }

      // (省略した関数をここに展開)
      updateDirection=()=>{switch(movePattern){case'horizontal':direction={x:1,y:0};break;case'diagonal1':direction={x:dirX,y:dirY};break;case'diagonal2':direction={x:-dirX,y:dirY};break;}};stopBall=()=>{if(animationId&&!isStopping){isStopping=!0;hasReachedEdge=!1}};moveBall=()=>{const e={width:window.innerWidth,height:window.innerHeight};if(isStopping)if(hasReachedEdge){const t={x:(e.width-ballSize.width)/2,y:(e.height-ballSize.height)/2};stopProgress+=1/stopDuration;const o=1-Math.pow(1-stopProgress,3);position.x=returnStartPosition.x+(t.x-returnStartPosition.x)*o;position.y=returnStartPosition.y+(t.y-returnStartPosition.y)*o;if(stopProgress>=1){position=t;cancelAnimationFrame(animationId);animationId=null;isStopping=!1;return}}else{position.x+=direction.x*speed;position.y+=direction.y*speed;if(position.x<=0||position.x+ballSize.width>=e.width||position.y<=0||position.y+ballSize.height>=e.height){playCollisionSound();hasReachedEdge=!0;returnStartPosition={...position};stopProgress=0}}else{position.x+=direction.x*speed;position.y+=direction.y*speed;if(movePattern==="horizontal"){if(position.x<=0||position.x+ballSize.width>=e.width){direction.x*=-1;playCollisionSound()}}else if(position.x<=0||position.x+ballSize.width>=e.width||position.y<=0||position.y+ballSize.height>=e.height){direction.x*=-1;direction.y*=-1;playCollisionSound()}}position.x=Math.max(0,Math.min(position.x,e.width-ballSize.width));position.y=Math.max(0,Math.min(position.y,e.height-ballSize.height));ball.style.left=position.x+"px";ball.style.top=position.y+"px";if(animationId)animationId=requestAnimationFrame(moveBall)};

      // --- イベントリスナー ---
      clientBallColorSelect.addEventListener("change", () => {
        initAudio(); // ユーザー操作をきっかけにオーディオを初期化
        if (audioContext && audioContext.state === 'suspended') audioContext.resume();
        const newColor = clientBallColorSelect.value;
        ball.style.backgroundColor = newColor;
        socket.emit("ball-control", { type: "ballColor", value: newColor });
      });

      socket.on("ball-control", (data) => {
        switch (data.type) {
          case "start": isStopping=false; hasReachedEdge=false; if(colorChooser)colorChooser.style.display="none"; if(isAudioEnabled&&isAudioInitialized&&audioContext.state==='suspended')audioContext.resume(); if(!animationId){updateDirection();animationId=requestAnimationFrame(moveBall)} break;
          case "stop": stopBall(); break;
          case "audioToggle": isAudioEnabled = data.value; if(isAudioEnabled) initAudio(); break;
          case "movePattern": movePattern = data.value; updateDirection(); break;
          case "speed": speed = data.value; break;
          case "ballColor": ball.style.backgroundColor = data.value; clientBallColorSelect.value = data.value; break;
          case "bgColor": document.body.style.backgroundColor = data.value; break;
        }
      });
      
      // ▼▼▼ 修正: BGMコントロールのリスナー ▼▼▼
      socket.on('music-start', (data) => {
        musicPlaylist = data.playlist;
        currentTrackIndex = data.startIndex;
        audioPlayer.volume = data.volume;
        playSongAtIndex(currentTrackIndex);
      });

      socket.on('music-control', (data) => {
        switch (data.type) {
          case 'pause':
            audioPlayer.pause();
            break;
          case 'resume':
            audioPlayer.play().catch(e => console.error("クライアント再生再開エラー:", e));
            break;
          case 'volume':
            audioPlayer.volume = data.value;
            break;
        }
      });
      
      // ▼▼▼ 追加: クライアント側で曲の終了を検知し、次の曲へ進む ▼▼▼
      audioPlayer.addEventListener('ended', () => {
        currentTrackIndex++;
        // プレイリストの最後に到達したら、次のプレイリストが送られてくるのを待つ
        // 自分でループ再生するとセラピストと同期がズレる可能性があるため、リストの範囲内でのみ再生
        if (currentTrackIndex < musicPlaylist.length) {
            playSongAtIndex(currentTrackIndex);
        }
      });
      
      setInterval(() => socket.emit('ping'), 30000);
      socket.on('connect', () => console.log('サーバーに再接続しました。 ID:', socket.id));
      socket.on('disconnect', (reason) => console.log('サーバーから切断されました。理由:', reason));

      const ballColors = [ "#FFFFFF", "#FFE3CB", "#FFB3BF", "#F5CEE6", "#C5E8F2", "#C3D4F3", "#BCE0DF", "#DFF5D6", "#FFFAD1", "#8AB5E6", "#E68D8A", "#B5E68A", "#4E7199", "#99514E", "#4E9967", "#FF0000", "#000000" ];
      function populateColorSelect(selectElem,colorList){if(!selectElem)return;colorList.forEach(color=>{const option=document.createElement("option");option.value=color;option.textContent=`⬛ ${color}`;option.style.backgroundColor=color;option.style.color=getContrastYIQ(color)==="black"?"#000":"#fff";selectElem.appendChild(option)})}
      function getContrastYIQ(hexcolor){hexcolor=hexcolor.replace("#","");const r=parseInt(hexcolor.substr(0,2),16),g=parseInt(hexcolor.substr(2,2),16),b=parseInt(hexcolor.substr(4,2),16);return((r*299)+(g*587)+(b*114))/1000>=128?'black':'white'}
      populateColorSelect(clientBallColorSelect, ballColors);
      clientBallColorSelect.value = "#FFFFFF"; 
      
      window.addEventListener("resize", () => {
        if (!animationId) {
          position = { x: (window.innerWidth - ballSize.width) / 2, y: (window.innerHeight - ballSize.height) / 2 };
          ball.style.left = position.x + 'px'; ball.style.top = position.y + 'px';
        }
      });
    });
  </script>
</body>
</html>
