<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>EMDR Client</title>
  <style>
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden; 
      background-color: #000000; 
      font-family: sans-serif; 
    }
    #ball { 
      width: 50px; 
      height: 50px; 
      border-radius: 50%; 
      position: absolute; 
      background-color: #FFFFFF; 
    }
    #colorChooser { 
      position: absolute; 
      top: 30%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      background-color: rgba(255, 255, 255, 0.95); 
      padding: 25px; 
      border-radius: 12px; 
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); 
      text-align: center; 
      z-index: 10; 
    }
    #colorChooser label { 
      font-size: 18px; 
      color: #333; 
    }
    #colorChooser select { 
      margin-top: 10px; 
      padding: 5px; 
      font-size: 14px; 
      min-width: 150px; 
    }
    #colorChooser option { 
      padding: 4px; 
    }
  </style>
</head>
<body>
  <div id="colorChooser">
    <label for="clientBallColor">ボールの色を選んでください</label><br>
    <select id="clientBallColor"></select>
  </div>
  <div id="ball"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ページのHTML要素がすべて読み込まれてからスクリプトを実行する
    document.addEventListener('DOMContentLoaded', () => {
      const socket = io();

      // --- DOM要素の取得 ---
      const ball = document.getElementById("ball");
      const colorChooser = document.getElementById("colorChooser");
      const clientBallColorSelect = document.getElementById("clientBallColor");

      // --- BGM再生用オブジェクト ---
      const audioPlayer = new Audio();
      audioPlayer.volume = 0.5; // 初期音量

      // --- ボールの状態管理変数 ---
      const ballSize = { width: 50, height: 50 };
      let position = { x: (window.innerWidth - ballSize.width) / 2, y: (window.innerHeight - ballSize.height) / 2 };
      ball.style.left = position.x + "px";
      ball.style.top = position.y + "px";
      
      let direction = { x: 1, y: 0 };
      let speed = 5;
      let animationId = null;
      let movePattern = 'horizontal';

      // --- 停止シーケンス関連の変数 ---
      let isStopping = false;
      let hasReachedEdge = false;
      let stopProgress = 0;
      const stopDuration = 120; // 中央に戻るまでの時間（フレーム数）
      let returnStartPosition;

      // --- 衝突音関連の変数 ---
      const angle = 15;
      const angleRad = angle * Math.PI / 180;
      const dirX = Math.cos(angleRad);
      const dirY = Math.sin(angleRad);
      let audioContext;
      let panner;
      let panDirection = -1;
      let isAudioEnabled = false;
      let isAudioInitialized = false;

      // --- 関数定義 ---

      // 衝突音の初期化
      function initAudio() {
        if (isAudioInitialized) return;
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          panner = audioContext.createStereoPanner();
          panner.connect(audioContext.destination);
          isAudioInitialized = true;
        } catch(e) {
          console.error("Web Audio API is not supported in this browser.");
        }
      }

      // 衝突音を再生
      function playCollisionSound() {
        if (!isAudioEnabled || !isAudioInitialized) return;
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.connect(gainNode).connect(panner);
        panner.pan.setValueAtTime(panDirection, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
        panDirection *= -1;
      }

      // 動きのパターンに応じて進行方向を更新
      function updateDirection() {
        switch (movePattern) {
          case 'horizontal': direction = { x: 1, y: 0 }; break;
          case 'diagonal1': direction = { x: dirX, y: dirY }; break;
          case 'diagonal2': direction = { x: -dirX, y: dirY }; break;
        }
      }
      
      // 停止シーケンスを開始する
      function stopBall() {
        if (animationId && !isStopping) {
          isStopping = true;
          hasReachedEdge = false;
        }
      }

      // ボールを動かすメインの関数（アニメーションループ）
      function moveBall() {
        const screen = { width: window.innerWidth, height: window.innerHeight };
        
        if (isStopping) {
          if (!hasReachedEdge) {
            // ステップ1: まずは画面の端まで移動する
            position.x += direction.x * speed;
            position.y += direction.y * speed;

            let hitEdge = false;
            if (position.x <= 0 || position.x + ballSize.width >= screen.width || position.y <= 0 || position.y + ballSize.height >= screen.height) {
              hitEdge = true;
            }
            
            if (hitEdge) {
              playCollisionSound();
              hasReachedEdge = true;
              returnStartPosition = { ...position };
              stopProgress = 0;
            }
          } else {
            // ステップ2: 端に到達後、ゆっくり中央に戻る
            const center = { x: (screen.width - ballSize.width) / 2, y: (screen.height - ballSize.height) / 2 };
            stopProgress += 1 / stopDuration;
            const ease = 1 - Math.pow(1 - stopProgress, 3); // イージング効果

            position.x = returnStartPosition.x + (center.x - returnStartPosition.x) * ease;
            position.y = returnStartPosition.y + (center.y - returnStartPosition.y) * ease;

            if (stopProgress >= 1) {
              position = center;
              cancelAnimationFrame(animationId);
              animationId = null;
              isStopping = false;
              return; // アニメーションループを完全に停止
            }
          }
        } else {
          // 通常の往復運動
          position.x += direction.x * speed;
          position.y += direction.y * speed;
          if (movePattern === 'horizontal') {
            if (position.x <= 0 || position.x + ballSize.width >= screen.width) {
              direction.x *= -1;
              playCollisionSound();
            }
          } else {
            if (position.x <= 0 || position.x + ballSize.width >= screen.width || position.y <= 0 || position.y + ballSize.height >= screen.height) {
              direction.x *= -1;
              direction.y *= -1;
              playCollisionSound();
            }
          }
        }
        
        // 画面外にはみ出ないように位置を補正
        position.x = Math.max(0, Math.min(position.x, screen.width - ballSize.width));
        position.y = Math.max(0, Math.min(position.y, screen.height - ballSize.height));
        ball.style.left = position.x + "px";
        ball.style.top = position.y + "px";
        
        // アニメーションを継続
        if (animationId) {
          animationId = requestAnimationFrame(moveBall);
        }
      }

      // --- イベントリスナーの設定 ---

      // 最初にクライアントがボールの色を選択した時の処理
      clientBallColorSelect.addEventListener("change", () => {
        // ユーザー操作をきっかけにオーディオを初期化（ブラウザの自動再生ポリシー対策）
        initAudio();
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
        const newColor = clientBallColorSelect.value;
        ball.style.backgroundColor = newColor;
        socket.emit("ball-control", { type: "ballColor", value: newColor });
      });

      // セラピストからの操作指示を受け取るメインのリスナー
      socket.on("ball-control", (data) => {
        switch (data.type) {
          case "start":
            isStopping = false;
            hasReachedEdge = false;
            if (colorChooser) { colorChooser.style.display = "none"; }
            if (isAudioEnabled && isAudioInitialized && audioContext.state === 'suspended') { audioContext.resume(); }
            if (!animationId) {
              updateDirection();
              animationId = requestAnimationFrame(moveBall);
            }
            break;
          case "stop":
            stopBall();
            break;
          case "audioToggle":
            isAudioEnabled = data.value;
            if (isAudioEnabled) { initAudio(); }
            break;
          case "movePattern":
            movePattern = data.value;
            updateDirection();
            break;
          case "speed":
            speed = data.value;
            break;
          case "ballColor":
            ball.style.backgroundColor = data.value;
            clientBallColorSelect.value = data.value;
            break;
          case "bgColor":
            document.body.style.backgroundColor = data.value;
            break;
        }
      });
      
      // BGMの操作指示を受け取るリスナー
      socket.on('music-control', (data) => {
        switch (data.type) {
          case 'play':
            if (audioPlayer.src !== new URL(data.src, window.location.href).href) {
                audioPlayer.src = data.src;
            }
            audioPlayer.play();
            break;
          case 'pause':
            audioPlayer.pause();
            break;
          case 'volume':
            audioPlayer.volume = data.value;
            break;
        }
      });
      
      // Renderのスリープ対策
      setInterval(() => {
        socket.emit('ping');
      }, 30000);
      
      // 接続状態の監視
      socket.on('connect', () => {
        console.log('サーバーに再接続しました。 ID:', socket.id);
      });
      socket.on('disconnect', (reason) => {
        console.log('サーバーから切断されました。理由:', reason);
      });

      // --- 初期化処理 ---
      const ballColors = [ "#FFFFFF", "#FFE3CB", "#FFB3BF", "#F5CEE6", "#C5E8F2", "#C3D4F3", "#BCE0DF", "#DFF5D6", "#FFFAD1", "#8AB5E6", "#E68D8A", "#B5E68A", "#4E7199", "#99514E", "#4E9967", "#FF0000", "#000000" ];
      function populateColorSelect(selectElem, colorList) {
        if (!selectElem) return;
        colorList.forEach(color => {
          const option = document.createElement("option");
          option.value = color;
          option.textContent = `⬛ ${color}`;
          option.style.backgroundColor = color;
          option.style.color = getContrastYIQ(color) === "black" ? "#000" : "#fff";
          selectElem.appendChild(option);
        });
      }
      function getContrastYIQ(hexcolor) {
        hexcolor = hexcolor.replace("#", "");
        const r = parseInt(hexcolor.substr(0,2),16);
        const g = parseInt(hexcolor.substr(2,2),16);
        const b = parseInt(hexcolor.substr(4,2),16);
        const yiq = ((r*299)+(g*587)+(b*114))/1000;
        return (yiq >= 128) ? 'black' : 'white';
      }
      populateColorSelect(clientBallColorSelect, ballColors);
      clientBallColorSelect.value = "#FFFFFF"; 
      
      window.addEventListener("resize", () => {
        const screen = { width: window.innerWidth, height: window.innerHeight };
        if (!animationId) {
          position = { x: (screen.width - ballSize.width) / 2, y: (screen.height - ballSize.height) / 2 };
          ball.style.left = position.x + 'px';
          ball.style.top = position.y + 'px';
        }
      });
    });
  </script>
</body>
</html>
