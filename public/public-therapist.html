<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>EMDR Therapist Control</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: sans-serif; }
    
    #controlPanel {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 10;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .control-group { text-align: center; }
    .control-group label, #pattern-selector legend { display: block; margin-bottom: 8px; font-size: 13px; font-weight: bold; color: #333; }
    #slider { width: 200px; }
    #startBtn, #stopBtn, #musicToggleBtn { padding: 8px 18px; font-size: 15px; cursor: pointer; }
    #startBtn, #stopBtn { margin: 0 4px; }
    
    #pattern-selector { border: 1px solid #ccc; border-radius: 8px; padding: 8px 15px; margin: 0; }
    #pattern-selector legend { padding: 0 5px; margin-bottom: 5px; }
    #pattern-selector div { display: flex; justify-content: center; gap: 15px; }
    #pattern-selector label { font-weight: normal; cursor: pointer; margin-left: 3px; }

    .option-toggle { padding-bottom: 5px; }
    select { padding: 5px; font-size: 14px; }
    #volumeSlider { vertical-align: middle; cursor: pointer; width: 100px; }
    
    #ball { width: 50px; height: 50px; border-radius: 50%; position: absolute; background-color: #FFFFFF; }
    option { padding: 4px; }
  </style>
</head>
<body style="background-color: #000000;">

  <div id="controlPanel">
    <div class="control-group">
      <label for="slider">速度: <span id="speedDisplay">5</span></label>
      <input type="range" id="slider" min="1" max="100" value="5" />
    </div>
    <div class="control-group">
      <button id="startBtn">スタート</button>
      <button id="stopBtn">ストップ</button>
    </div>
    <div class="control-group">
      <fieldset id="pattern-selector">
        <legend>動きのパターン</legend>
        <div>
          <span><input type="radio" id="moveHorizontal" name="movePattern" value="horizontal" checked><label for="moveHorizontal">水平</label></span>
          <span><input type="radio" id="moveDiagonal1" name="movePattern" value="diagonal1"><label for="moveDiagonal1">斜め(左上↔)</label></span>
          <span><input type="radio" id="moveDiagonal2" name="movePattern" value="diagonal2"><label for="moveDiagonal2">斜め(右上↔)</label></span>
        </div>
      </fieldset>
    </div>
    <div class="control-group">
      <label for="ballColor">ボール色</label>
      <select id="ballColor"></select>
    </div>
    <div class="control-group">
      <label for="bgColor">背景色</label>
      <select id="bgColor"></select>
    </div>
    <div class="control-group option-toggle">
        <input type="checkbox" id="audioToggle">
        <label for="audioToggle">衝突音</label>
    </div>
    <div class="control-group">
      <label>BGM操作</label>
      <div>
        <button id="musicToggleBtn">再生</button>
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5" title="音量">
      </div>
    </div>
  </div>
  
  <div id="ball"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const socket = io();

      // DOM要素の取得
      const ball = document.getElementById("ball");
      const slider = document.getElementById("slider");
      const speedDisplay = document.getElementById("speedDisplay");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const ballColorSelect = document.getElementById("ballColor");
      const bgColorSelect = document.getElementById("bgColor");
      const movePatternRadios = document.querySelectorAll('input[name="movePattern"]');
      const audioToggle = document.getElementById('audioToggle');
      const musicToggleBtn = document.getElementById('musicToggleBtn');
      const volumeSlider = document.getElementById('volumeSlider');
      
      // EMDR関連の変数
      const ballSize = { width: 50, height: 50 };
      let position = { x: (window.innerWidth - ballSize.width) / 2, y: (window.innerHeight - ballSize.height) / 2 };
      ball.style.left = position.x + "px"; ball.style.top = position.y + "px";
      let direction = { x: 1, y: 0 };
      let speed = 5;
      let animationId = null;
      let movePattern = 'horizontal';
      
      let isStopping = false;
      let hasReachedEdge = false;
      let stopProgress = 0;
      const stopDuration = 120;
      let returnStartPosition;
      
      const angle = 15;
      const angleRad = angle * Math.PI / 180;
      const dirX = Math.cos(angleRad);
      const dirY = Math.sin(angleRad);
      
      // 衝突音関連の変数
      let audioContext;
      let panner;
      let panDirection = -1;
      let isAudioEnabled = false;
      let isAudioInitialized = false;

      // BGM関連の変数
      const audioPlayer = new Audio();
      const musicPlaylist = [
          '/audio/1 Blue Berry Pufffin.mp3', '/audio/2 A Step In The River.mp3', '/audio/3 Peak\'s Performance.mp3', '/audio/4 Jazz Hoyt.mp3', '/audio/5 Pop\'s Trilogy.mp3', '/audio/6 Redemption.mp3', '/audio/7 Oceanic Fellings.mp3', '/audio/8 Paco Bell.mp3', '/audio/9 Round The Lake.mp3', '/audio/10 Piano R Squared.mp3', '/audio/11 New (No) Frills - Shaken, Not Stirred.mp3'
      ];
      let shuffledPlaylist = [];
      let currentTrackIndex = 0;
      audioPlayer.volume = 0.5;

      // --- 関数定義 ---

      // 衝突音初期化・再生
      function initAudio() { if (isAudioInitialized) return; try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); panner = audioContext.createStereoPanner(); panner.connect(audioContext.destination); isAudioInitialized = true; } catch(e) { console.error("Web Audio API is not supported in this browser."); } }
      function playCollisionSound() { if (!isAudioEnabled || !isAudioInitialized) return; if (audioContext.state === 'suspended') { audioContext.resume(); } const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(440, audioContext.currentTime); oscillator.connect(gainNode).connect(panner); panner.pan.setValueAtTime(panDirection, audioContext.currentTime); gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1); panDirection *= -1; }
      
      // 動きのパターン更新
      function updateDirection() { switch (movePattern) { case 'horizontal': direction = { x: 1, y: 0 }; break; case 'diagonal1': direction = { x: dirX, y: dirY }; break; case 'diagonal2': direction = { x: -dirX, y: dirY }; break; } }
      
      // ボールの動き
      function stopBall() { if (animationId && !isStopping) { isStopping = true; hasReachedEdge = false; } }
      function moveBall() {
        const screen = { width: window.innerWidth, height: window.innerHeight };
        if (isStopping) {
          if (!hasReachedEdge) {
            position.x += direction.x * speed; position.y += direction.y * speed;
            let hitEdge = (position.x <= 0 || position.x + ballSize.width >= screen.width || position.y <= 0 || position.y + ballSize.height >= screen.height);
            if (hitEdge) { playCollisionSound(); hasReachedEdge = true; returnStartPosition = { ...position }; stopProgress = 0; }
          } else {
            const center = { x: (screen.width - ballSize.width) / 2, y: (screen.height - ballSize.height) / 2 };
            stopProgress += 1 / stopDuration;
            const ease = 1 - Math.pow(1 - stopProgress, 3);
            position.x = returnStartPosition.x + (center.x - returnStartPosition.x) * ease;
            position.y = returnStartPosition.y + (center.y - returnStartPosition.y) * ease;
            if (stopProgress >= 1) { position = center; cancelAnimationFrame(animationId); animationId = null; isStopping = false; }
          }
        } else {
          position.x += direction.x * speed; position.y += direction.y * speed;
          if (movePattern === 'horizontal' && (position.x <= 0 || position.x + ballSize.width >= screen.width)) { direction.x *= -1; playCollisionSound(); } 
          else if (movePattern !== 'horizontal' && (position.x <= 0 || position.x + ballSize.width >= screen.width || position.y <= 0 || position.y + ballSize.height >= screen.height)) { direction.x *= -1; direction.y *= -1; playCollisionSound(); }
        }
        position.x = Math.max(0, Math.min(position.x, screen.width - ballSize.width));
        position.y = Math.max(0, Math.min(position.y, screen.height - ballSize.height));
        ball.style.left = position.x + "px"; ball.style.top = position.y + "px";
        if (animationId) { animationId = requestAnimationFrame(moveBall); }
      }

      // BGM再生関連
      function shufflePlaylist(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
      function playMusic() {
        if (shuffledPlaylist.length === 0) { shuffledPlaylist = shufflePlaylist([...musicPlaylist]); currentTrackIndex = 0; }
        const trackToPlay = shuffledPlaylist[currentTrackIndex];
        audioPlayer.src = trackToPlay;
        audioPlayer.play().catch(e => console.error("Audio play failed:", e));
        musicToggleBtn.textContent = '停止';
        socket.emit('music-control', { type: 'play', src: trackToPlay, time: 0 });
      }
      function pauseMusic() {
        audioPlayer.pause();
        musicToggleBtn.textContent = '再生';
        socket.emit('music-control', { type: 'pause' });
      }

      // --- イベントリスナー ---
      startBtn.addEventListener("click", () => { if (isAudioEnabled) { initAudio(); if (audioContext.state === 'suspended') { audioContext.resume(); } } isStopping = false; hasReachedEdge = false; if (!animationId) { updateDirection(); animationId = requestAnimationFrame(moveBall); } socket.emit("ball-control", { type: "start" }); });
      stopBtn.addEventListener("click", () => { stopBall(); socket.emit("ball-control", { type: "stop" }); });
      slider.addEventListener("input", () => { speed = parseInt(slider.value); speedDisplay.textContent = speed; socket.emit("ball-control", { type: "speed", value: speed }); });
      audioToggle.addEventListener('change', () => { isAudioEnabled = audioToggle.checked; if (isAudioEnabled) { initAudio(); } socket.emit("ball-control", { type: "audioToggle", value: isAudioEnabled }); });
      movePatternRadios.forEach(radio => { radio.addEventListener('change', () => { if(animationId) return; movePattern = radio.value; updateDirection(); socket.emit("ball-control", { type: "movePattern", value: movePattern }); }); });
      ballColorSelect.addEventListener("change", () => { const color = ballColorSelect.value; ball.style.backgroundColor = color; socket.emit("ball-control", { type: "ballColor", value: color }); });
      bgColorSelect.addEventListener("change", () => { const color = bgColorSelect.value; document.body.style.backgroundColor = color; socket.emit("ball-control", { type: "bgColor", value: color }); });
      
      musicToggleBtn.addEventListener('click', () => { if (audioPlayer.paused) { playMusic(); } else { pauseMusic(); } });
      volumeSlider.addEventListener('input', () => { const volume = volumeSlider.value; audioPlayer.volume = volume; socket.emit('music-control', { type: 'volume', value: volume }); });
      audioPlayer.addEventListener('ended', () => { currentTrackIndex++; if (currentTrackIndex >= shuffledPlaylist.length) { shuffledPlaylist = shufflePlaylist([...musicPlaylist]); currentTrackIndex = 0; } playMusic(); });

      // Socket.IOイベント
      socket.on("ball-control", (data) => { if (data.type === "ballColor") { ball.style.backgroundColor = data.value; ballColorSelect.value = data.value; } });
      socket.on('connect', () => { console.log('サーバーに接続しました。 ID:', socket.id); });
      socket.on('disconnect', (reason) => { console.log('サーバーから切断されました。理由:', reason); });
      setInterval(() => { socket.emit('ping'); }, 30000);

      // 初期化処理
      const ballColors = [ "#FFFFFF", "#FFE3CB", "#FFB3BF", "#F5CEE6", "#C5E8F2", "#C3D4F3", "#BCE0DF", "#DFF5D6", "#FFFAD1", "#8AB5E6", "#E68D8A", "#B5E68A", "#4E7199", "#99514E", "#4E9967", "#FF0000", "#000000" ];
      const bgColors = [ "#FFFFFF", "#FFFAFA", "#F0FFFF", "#FFFFF0", "#C0C0C0", "#000000" ];
      function populateColorSelect(selectElem, colorList) { if (!selectElem) return; colorList.forEach(color => { const option = document.createElement("option"); option.value = color; option.textContent = `⬛ ${color}`; option.style.backgroundColor = color; option.style.color = getContrastYIQ(color) === "black" ? "#000" : "#fff"; selectElem.appendChild(option); }); }
      function getContrastYIQ(hexcolor) { hexcolor = hexcolor.replace("#", ""); const r = parseInt(hexcolor.substr(0,2),16); const g = parseInt(hexcolor.substr(2,2),16); const b = parseInt(hexcolor.substr(4,2),16); const yiq = ((r*299)+(g*587)+(b*114))/1000; return (yiq >= 128) ? 'black' : 'white'; }
      populateColorSelect(ballColorSelect, ballColors);
      populateColorSelect(bgColorSelect, bgColors);
      ballColorSelect.value = "#FFFFFF";
      bgColorSelect.value = "#000000";

      // キーボード操作
      window.addEventListener('keydown', (event) => { switch (event.key) { case 'Enter': if (animationId && !isStopping) { stopBtn.click(); } else { startBtn.click(); } event.preventDefault(); break; case 'ArrowRight': slider.value = Math.min(100, parseInt(slider.value) + 1); slider.dispatchEvent(new Event('input')); event.preventDefault(); break; case 'ArrowLeft': slider.value = Math.max(1, parseInt(slider.value) - 1); slider.dispatchEvent(new Event('input')); event.preventDefault(); break; } });
      window.addEventListener("resize", () => { const screen = { width: window.innerWidth, height: window.innerHeight }; if (!animationId) { position = { x: (screen.width - ballSize.width) / 2, y: (screen.height - ballSize.height) / 2 }; ball.style.left = position.x + 'px'; ball.style.top = position.y + 'px'; } });
    });
  </script>
</body>
</html>
